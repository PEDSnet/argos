#' Table name construction based on config
#'
#' Given the base name of a database table and metadata about its intended
#' schema, construct a fully qualified schema/table name for use in {dbplyr}.
#'
#' @param name A character vector with the base name of the table.  An attempt
#'   is made to locate the base name in `config('table_names')`, and if this
#'   is successful the replacement value is used.  Otherwise, the name is used
#'   unchanged.
#' @param schema_tag A character vector indicating the config element in which
#'   to look up the schema name.  Common values include 'cdm_schema' or
#'   'results_schema'.  If no such config element exists, then the
#'   schema tag is used unchanged.
#' @param db A database connection, used to perform quoting of identifiers.
qual_name <- function(name, schema_tag, db = config('db_src'))
  get_argos_default()$qual_name(name, schema_tag, db)

argos$set(
  'public', 'qual_name',
  #' @name qual_name-method
  #' @inherit qual_name
  function(name, schema_tag, db = self$config('db_src')) {
    if (inherits(name, c('ident_q', 'dbplyr_schema'))) return(name)
    name_map <- self$config('table_names')
    name <- base::ifelse(hasName(name_map, name), name_map[[name]], name)
    if (! is.na(schema_tag)) {
      if (self$config_exists(schema_tag)) schema_tag <- config(schema_tag)
      if (! is.na(schema_tag)) {
        if (packageVersion('dbplyr') < '2.0.0') { # nocov start
          name <- DBI::dbQuoteIdentifier(self$dbi_con(db), name)
        } # nocov end
        name <- dbplyr::in_schema(schema_tag,name)
      }
    }
    name
  })


#' Construct a (possibly schema-qualified) intermediate result table name
#'
#' If the name passed in is already the result of a call to
#' [dbplyr::in_schema()], then no further modification is made.  Otherwise,
#' schema qualification is done based on the value of `temporary`, and name
#' modification based on the values of `local` and `no_tag`.
#'
#' By default, a request-specific string called the results tag, whose value is
#' set in configuration, is added to the table name.  This is done to prevent
#' tables from this request colliding with those from other requests, if you use
#' a common scnema across data requests.  If you know this is not appropriate
#' (for example, you're passing the name of a table generated by a previous
#' request, and including it's tag in `name`), then you can disable the
#' addition on a one-time basis by setting `results_tag` to FALSE..
#'
#' You also have the option of designating a table name as `local` or not; for
#' the sense of this designation, see [output_tbl()].  A local designation
#' results in the string `_loc` (or whatever else is configured as the local
#' name tag) being added to the table name.
#'
#' This function can be used to get the complete specification for an existing
#' table whose name is known, or called without a `name` value to generate a new
#' table name that is unlikely to collide with an existing table.
#'
#' @param name The name of the table.
#' @param temporary Logical indicating whether the table is temporary.  For some
#'   database systems, this means it must not be schema-qualified.
#' @param results_tag The request tag to add to the table name.  If NA or a
#'   logically false value, no tag is added.  If a character string, that is
#'   used as the tag.  Otherwise, the `config('results_name_tag')` string is
#'   used.
#' @param local_tag The local tag to add to the table name.   If NA or a
#'   logically false value, no tag is added.  If a character string, that is
#'   used as the tag.  Otherwise, the `config('local_name_tag')` string is
#'   used.
#' @param schema A label for the name of the schema to be included in the
#'   result, if `temporary` is false.  If a config element of the same name
#'   exists, its value is used; otherwise, the `schema` parameter is used as
#'   the schema name itself.
#' @param db A database connection, used in more recent versions of dbplyr to
#'   insure quoting of table names matches what the database expects
#'
#' @return The resultant name
#' @export
#' @md
intermed_name <- function(name = paste0(sample(letters, 12, replace = TRUE),
                                           collapse = ""),
                          temporary = ! config('retain_intermediates'),
                          results_tag =  TRUE,
                          local_tag = NA,
                          schema = 'results_schema',
                          db = config('db_src'))
  get_argos_default()$intermed_name(name, temporary, results_tag, local_tag,
                                    schema, db)


argos$set(
  'public', 'intermed_name',
  #' @name intermed_name-method
  #' @inherit intermed_name
  function(name = paste0(sample(letters, 12, replace = TRUE),
                         collapse = ""),
           temporary = ! self$config('retain_intermediates'),
           results_tag =  TRUE,
           local_tag = NA,
           schema = 'results_schema',
           db = self$config('db_src')) {
    # Add a request-specific tag to the name, if so configured
    .add_name_tag <- function(name, tag) {
      if ( ! is.na(tag)) {
        add_tag <- function(x) {
          no_tag <- ! grepl(paste0(tag,'$'), x)
          x[no_tag] <- paste0(x[no_tag], tag)
          x
        }
        if (inherits(name, c('ident_q', 'dbplyr_schema'))) {
          # Best guess - works but relies on stringification of dbplyr::in_schema()
          if (packageVersion('dbplyr') < '2.0.0') { # nocov start
            name <- gsub('["`\']', '', dbplyr::as.sql(name))
          } # nocov end
          else {
            name <- gsub('["`\']', '', dbplyr::as.sql(name, self$dbi_con(db)))
          }
          parts <- regmatches(name, regexec('^"*(.+?)"*\\."*(.+?)"*$', name))
          name <- dbplyr::in_schema(parts[[1]][2], add_tag(parts[[1]][3]))
        }
        else {
          name <- add_tag(name)
        }
      }
      name
    }

    if (! is.na(local_tag) && (is.character(local_tag) || local_tag)) {
      if (! is.character(local_tag)) local_tag <- self$config('local_name_tag')
      name <- .add_name_tag(name, tag = local_tag)
    }
    if (! is.na(results_tag) && (is.character(results_tag) || results_tag)) {
      if (! is.character(results_tag))
        results_tag <- self$config('results_name_tag')
      name <- .add_name_tag(name, tag = results_tag)
    }
    self$qual_name(name = name,
                   schema_tag = base::ifelse(temporary, NA, schema),
                   db = db)
  })

#' Construct a fully qualified results table name
#'
#' This convenience function behaves similarly to [intermed_name()], except that
#' the table name must always be provided, and the result is always treated as a
#' non-temporary table.
#'
#' @param name The name of the table.
#' @param results_tag The request tag to add to the table name.  If NA or a
#'   logically false value, no tag is added.  If a character string, that is
#'   used as the tag.  Otherwise, the `config('results_name_tag')` string is
#'   used.
#' @param local_tag The local tag to add to the table name.   If NA or a
#'   logically false value, no tag is added.  If a character string, that is
#'   used as the tag.  Otherwise, the `config('local_name_tag')` string is
#'   used.
#' @param db A database connection, used in more recent versions of dbplyr to
#'   insure quoting of table names matches what the database expects
#'
#' @return The resultant name
#' @export
#' @md
results_name <- function(name, results_tag =  TRUE, local_tag = NA,
                         db = config('db_src'))
  get_argos_default()$results_name(name, results_tag, local_tag, db)

argos$set(
  'public', 'results_name',
  #' @name results_name-method
  #' @inherit results_name
  function(name, results_tag =  TRUE, local_tag = NA,
           db = self$config('db_src')) {
    self$intermed_name(name = name, temporary = FALSE,
                       results_tag = results_tag, local_tag = local_tag,
                       db = db)
})

# Try to figure out schema/table expressions in various forms
argos$set( # nocov start
  'private', 'parse_tblspec',
  function(spec) {
    if (inherits(spec, 'Id')) {
      elts <- spec
    }
    else if (inherits(spec, c('ident_q', 'dbplyr_schema'))) {
      elts <- format(spec)
    }
    else if ((grepl('.', spec, fixed = TRUE) && ! grepl('["`]', spec))) {
      # If we have an unquoted string with a '.', assume schema.table
      elts <- unlist(strsplit(as.character(spec), '.', fixed = TRUE))
    }
    else if (grepl('["`].+["`]\\.["`]', spec)) {
      # And one simple-minded try at a quoted identifier string
      elts <-
        gsub('["`]', '',
             unlist(strsplit(as.character(spec), '["`].["`]')))
    }
    else {
      elts <- spec
    }
    names(elts) <- rev(c('table', 'schema', 'catalog')[1:length(elts)])
    elts
    # nocov end
  })
